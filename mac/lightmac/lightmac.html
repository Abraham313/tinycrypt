<h3>Introduction</h3>

A <em>Message Authentication Code</em> or MAC is a cryptographic primitive that enables two parties using a shared secret key to authenticate messages exchanged between them. 

MACs are used daily to secure online communications and will inevitably become a critical component of embedded systems in the future that have wireless functionality; specifically passive, low-power and IoT devices. 

Some MACs are constructed from cryptographic hash algorithms. The <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.198-1.pdf">Hash-based message authentication code (HMAC)</a> published in 1996 for example recommended using MD5 or SHA-1. However, due to resources required for these hash functions, they were never suitable for microcontrollers. 

Other MACs are constructed from block ciphers and this is more ideal for a developer where ROM and RAM are in short supply since there's already a number of lightweight block ciphers available. 

There's no shortage of cryptographic solutions for desktop computers and mobile devices, however there still remains a significant problem with some of the current standardized algorithms when attempting to implement for resource constrained software or hardware devices. 

A draft <a href="http://csrc.nist.gov/publications/drafts/nistir-8114/nistir_8114_draft.pdf">Report on Lightweight Cryptography</a> published by NIST in August 2016 states that none of the NIST approved hash functions are suitable for resource constrained environments based on the findings in <a href="http://eprint.iacr.org/2009/260">A Study on RAM Requirements of Various SHA-3 Candidates on Low-cost 8-bit CPUs</a>

<img src="https://tinycrypt.files.wordpress.com/2017/03/unsuitable.png" alt="" width="640" height="182" class="aligncenter size-full wp-image-2161" />

There's currently an effort on part of engineers, cryptographers and organizations to design, evaluate and standardize lightweight cryptographic primitives for the embedded industry.

Whether we agree or disagree on the need to embed wireless devices in everyday objects, there will be many that have networking or wireless functionality in future which will require robust encryption solutions.

<h3>LightMAC</h3>

<a href="https://eprint.iacr.org/2016/190">A MAC Mode for Lightweight Block Ciphers</a> was designed by <a href="https://www.atul.be/">Atul Luykx</a>, <a href="http://homes.esat.kuleuven.be/~preneel/">Bart Preneel</a>, <a href="http://www.dtu.dk/english/service/phonebook/person?id=91243&amp;tab=2&amp;qt=dtupublicationquery">Elmar Tischhauser</a>, Kan Yasuda and published in 2016.

<p align="center">
$latex \begin{array}{l}
\\\hline 
\textbf{Algorithm 1: }\text{LightMAC} _{K_1,K_2}(M)
\\\hline
\quad\textbf{Input: } K_1, K_2\in \{0, 1\}^k,\: M\in \{0,1\}^{\leq 2^s(n-s)}\\
\quad\textbf{Output: } T\in\{0, 1\}^t\\
\textbf{\scriptsize{1}}\;\; V\leftarrow 0^n\in\{0, 1\}^n\\
\textbf{\scriptsize{2}}\;\; M[1]M[2]\cdots M[\ell]\xleftarrow{n-s}M\\
\textbf{\scriptsize{3}}\;\; \textbf{for } i = 1\textbf{ to } \ell - 1\textbf{ do}\\
\textbf{\scriptsize{4}}\;\; \mid V\leftarrow V\oplus E_{K_1}(i_s M[i])\\
\textbf{\scriptsize{5}}\;\; \textbf{end}\\
\textbf{\scriptsize{6}}\;\; V\leftarrow V\oplus (M[\ell]10^\ast)\\
\textbf{\scriptsize{7}}\;\; T\leftarrow \lfloor E_{K_2}(V)\rfloor_t\\
\textbf{\scriptsize{8}}\;\; \textbf{return } T
  \\\hline
\end{array}$
</p>

The other lightweight MAC algorithms under evaluation by NIST are <a href="https://eprint.iacr.org/2014/386.pdf">Chaskey</a> and TuLp. I've already covered <a href="https://tinycrypt.wordpress.com/2017/01/10/asmcodes-chaskey/">Chaskey in a previous post.</a>

All code and details of the algorithm shown here are derived from reference implementations provided by Atul <a href="https://github.com/KULeuven-COSIC/lightmac">here on github</a>

Any developers that require a reference implementation should use those source codes instead of what's shown here.

Instead of using PRESENT block cipher, I'll use SPECK64/128 due to the ARX design which is much easier to implement on x86 architecture. 

<h3>Block Cipher Parameters</h3>

LightMAC is a mode of operation and depends directly on an external block cipher.

The only other block ciphers that come close to the size of Speck would be XTEA or Chaskey. The following is a list of parameters recommended for use with Speck.

<img src="https://tinycrypt.files.wordpress.com/2017/03/speck_params.png" alt="" width="640" height="499" class="aligncenter size-full wp-image-2168" />

<h3>LightMAC Parameters</h3>

The authors define the following in reference material which are based on the block cipher.

<ul>
	<li><strong>COUNTER_LENGTH</strong></li>
Length of the protected counter sum in bytes. Not greater than N/2.

	<li><strong>TAG_LENGTH</strong></li>
Length of tag in bytes. Should be at least 64-bits but not greater than N.

	<li><strong>BLOCK_LENGTH</strong></li>
Length of block in bytes. Same as N.

	<li><strong>BC_KEY_LENGTH</strong></li>
Length of block cipher key. The MAC key is twice this length.
</ul>

The following table shows some example parameters using existing lightweight block ciphers.

<table>
  <tr>
    <th>Cipher (E)<br></th>
    <th>Block Length (N)<br></th>
    <th>Cipher Key Length <br></th>
    <th>MAC Key Length (K)<br></th>
    <th>Counter Length (S)<br></th>
    <th>Tag Length (T)<br></th>
  </tr>
  <tr>
    <td>PRESENT</td>
    <td>64-bits</td>
    <td>128-bits</td>
    <td>256-bits</td>
    <td>32-bits<br></td>
    <td>64-bits<br></td>
  </tr>
  <tr>
    <td>SPECK</td>
    <td>64-bits</td>
    <td>128-bits</td>
    <td>256-bits</td>
    <td>32-bits<br></td>
    <td>64-bits<br></td>
  </tr>
  <tr>
    <td>AES</td>
    <td>128-bits<br></td>
    <td>128-bits</td>
    <td>256-bits</td>
    <td>32-bits<br></td>
    <td>128-bits</td>
  </tr>
</table>

<h3>Initialization</h3>

In the specification, V denotes an intermediate/local variable of cipher block size N. It is initialized to zero and updated after every encryption using an XOR operation with ciphertext before returning the result in T (truncated if required) 

But in my own implementation, I assume T to be of cipher block size N and initialize it to zero. I then update T instead which is why I prefer readers use the reference implementation instead of what's shown here. :)

My reason for not allocating space for V and using T directly is simply to reduce the amount of code required for the assembly code. 

<img src="https://tinycrypt.files.wordpress.com/2017/03/init.png" alt="" width="351" height="116" class="aligncenter size-full wp-image-2188" />

<h3>Updating</h3>

The update process is very similar to what you see used in cryptographic hash algorithms. I was gonna have a more detailed description here but I think comments should be clear enough.  

<img src="https://tinycrypt.files.wordpress.com/2017/03/update_proc.png" alt="" width="478" height="306" class="aligncenter size-full wp-image-2173" />

<h3>Finalization</h3>

An end bit (0x80) is appended to M buffer along with any data remaining or none if the input length was a multiple of the block cipher length.

This is then XORed with any previous cipher block state before being encrypted with the 2nd key before returning.

<img src="https://tinycrypt.files.wordpress.com/2017/03/final_proc.png" alt="" width="387" height="162" class="aligncenter size-full wp-image-2164" />

<h3>x86 Assembly code</h3>

First, here's the SPECK block cipher using 64-bit block and 128-bit key.

<pre style='color:#000000;background:#ffffff;'><span style='color:#004a43;'>%define</span><span style='color:#004a43;'> SPECK_RNDS    27</span>
<span style='color:#696969;'>; *****************************************</span>
<span style='color:#696969;'>; Light MAC parameters based on SPECK64-128</span>
<span style='color:#696969;'>;</span>
<span style='color:#696969;'>; N = 64-bits</span>
<span style='color:#696969;'>; K = 128-bits</span>
<span style='color:#696969;'>;</span>
<span style='color:#004a43;'>%define</span><span style='color:#004a43;'> COUNTER_LENGTH 4  </span><span style='color:#696969;'>; should be &lt;= N/2</span>
<span style='color:#004a43;'>%define</span><span style='color:#004a43;'> BLOCK_LENGTH   8  </span><span style='color:#696969;'>; equal to N</span>
<span style='color:#004a43;'>%define</span><span style='color:#004a43;'> TAG_LENGTH     8  </span><span style='color:#696969;'>; &gt;= 64 &amp;&amp; &lt;= N</span>
<span style='color:#004a43;'>%define</span><span style='color:#004a43;'> BC_KEY_LENGTH 16  </span><span style='color:#696969;'>; K</span>

<span style='color:#004a43;'>%define</span><span style='color:#004a43;'> ENCRYPT speck64_encryptx</span>
<span style='color:#004a43;'>%define</span><span style='color:#004a43;'> LIGHTMAC_KEY_LENGTH BC_KEY_LENGTH*2 </span><span style='color:#696969;'>; K*2</span>
    
<span style='color:#004a43;'>%define</span><span style='color:#004a43;'> k0 edi    </span>
<span style='color:#004a43;'>%define</span><span style='color:#004a43;'> k1 ebp    </span>
<span style='color:#004a43;'>%define</span><span style='color:#004a43;'> k2 ecx    </span>
<span style='color:#004a43;'>%define</span><span style='color:#004a43;'> k3 esi</span>

<span style='color:#004a43;'>%define</span><span style='color:#004a43;'> x0 ebx    </span>
<span style='color:#004a43;'>%define</span><span style='color:#004a43;'> x1 edx</span>

<span style='color:#696969;'>; esi = input</span>
<span style='color:#696969;'>; ebp = key</span>

<span style='color:#e34adc;'>speck64_encryptx:</span>   
      <span style='color:#800000;font-weight:bold;'>pushad</span>

      <span style='color:#800000;font-weight:bold;'>push</span>    <span style='color:#000080;'>esi</span>            <span style='color:#696969;'>; save M</span>
      
      <span style='color:#800000;font-weight:bold;'>lodsd</span>                  <span style='color:#696969;'>; x0 = x-&gt;w[0]</span>
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> x0
      <span style='color:#800000;font-weight:bold;'>lodsd</span>                  <span style='color:#696969;'>; x1 = x-&gt;w[1]</span>
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> x1
      
      <span style='color:#800000;font-weight:bold;'>mov</span>     <span style='color:#000080;'>esi</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>ebp</span>       <span style='color:#696969;'>; esi = key</span>
      <span style='color:#800000;font-weight:bold;'>lodsd</span>
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> k0        <span style='color:#696969;'>; k0 = key[0] </span>
      <span style='color:#800000;font-weight:bold;'>lodsd</span>
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> k1        <span style='color:#696969;'>; k1 = key[1]</span>
      <span style='color:#800000;font-weight:bold;'>lodsd</span>
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> k2        <span style='color:#696969;'>; k2 = key[2]</span>
      <span style='color:#800000;font-weight:bold;'>lodsd</span> 
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> k3        <span style='color:#696969;'>; k3 = key[3]    </span>
      <span style='color:#800000;font-weight:bold;'>xor</span>     <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>eax</span>       <span style='color:#696969;'>; i = 0</span>
<span style='color:#e34adc;'>spk_el:</span>
      <span style='color:#696969;'>; x0 = (ROTR32(x0, 8) + x1) ^ k0;</span>
      <span style='color:#800000;font-weight:bold;'>ror</span>     x0<span style='color:#808030;'>,</span> <span style='color:#008c00;'>8</span>
      <span style='color:#800000;font-weight:bold;'>add</span>     x0<span style='color:#808030;'>,</span> x1
      <span style='color:#800000;font-weight:bold;'>xor</span>     x0<span style='color:#808030;'>,</span> k0
      <span style='color:#696969;'>; x1 = ROTL32(x1, 3) ^ x0;</span>
      <span style='color:#800000;font-weight:bold;'>rol</span>     x1<span style='color:#808030;'>,</span> <span style='color:#008c00;'>3</span>
      <span style='color:#800000;font-weight:bold;'>xor</span>     x1<span style='color:#808030;'>,</span> x0
      <span style='color:#696969;'>; k1 = (ROTR32(k1, 8) + k0) ^ i;</span>
      <span style='color:#800000;font-weight:bold;'>ror</span>     k1<span style='color:#808030;'>,</span> <span style='color:#008c00;'>8</span>
      <span style='color:#800000;font-weight:bold;'>add</span>     k1<span style='color:#808030;'>,</span> k0
      <span style='color:#800000;font-weight:bold;'>xor</span>     k1<span style='color:#808030;'>,</span> <span style='color:#000080;'>eax</span>
      <span style='color:#696969;'>; k0 = ROTL32(k0, 3) ^ k1;</span>
      <span style='color:#800000;font-weight:bold;'>rol</span>     k0<span style='color:#808030;'>,</span> <span style='color:#008c00;'>3</span>
      <span style='color:#800000;font-weight:bold;'>xor</span>     k0<span style='color:#808030;'>,</span> k1    
      <span style='color:#800000;font-weight:bold;'>xchg</span>    k3<span style='color:#808030;'>,</span> k2
      <span style='color:#800000;font-weight:bold;'>xchg</span>    k3<span style='color:#808030;'>,</span> k1
      <span style='color:#696969;'>; i++</span>
      <span style='color:#800000;font-weight:bold;'>inc</span>     <span style='color:#000080;'>eax</span>
      <span style='color:#800000;font-weight:bold;'>cmp</span>     <span style='color:#000080;'>al</span><span style='color:#808030;'>,</span> SPECK_RNDS    
      <span style='color:#800000;font-weight:bold;'>jnz</span>     <span style='color:#e34adc;'>spk_el</span>
      
      <span style='color:#800000;font-weight:bold;'>pop</span>     <span style='color:#000080;'>edi</span>    
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> x0        <span style='color:#696969;'>; x-&gt;w[0] = x0</span>
      <span style='color:#800000;font-weight:bold;'>stosd</span>
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> x1        <span style='color:#696969;'>; x-&gt;w[1] = x1</span>
      <span style='color:#800000;font-weight:bold;'>stosd</span>
      <span style='color:#800000;font-weight:bold;'>popad</span>
      <span style='color:#800000;font-weight:bold;'>ret</span>
</pre>

Now LightMAC.

You might notice how ctr and idx variables are initialized to zero at the same time using CDQ instruction. Once PUSHAD is executed, it preserves EDX on the stack and is then used as the protected counter sum S.

Although we convert the counter to big endian format before saving in block buffer, it wouldn't affect the security to skip this. I've retained it for compatibility with reference but might remove it later.

<pre style='color:#000000;background:#ffffff;'><span style='color:#696969;'>; void lightmac_tag(const void *msg, uint32_t msglen, </span>
<span style='color:#696969;'>;     void *tag, void* mkey) </span>
<span style='color:#e34adc;'>lightmac_tagx:</span>
<span style='color:#e34adc;'>_lightmac_tagx:</span>
      <span style='color:#800000;font-weight:bold;'>pushad</span>
      <span style='color:#800000;font-weight:bold;'>lea</span>     <span style='color:#000080;'>esi</span><span style='color:#808030;'>,</span> <span style='color:#808030;'>[</span><span style='color:#000080;'>esp</span><span style='color:#808030;'>+</span><span style='color:#008c00;'>32</span><span style='color:#008c00;'>+4</span><span style='color:#808030;'>]</span><span style='color:#696969;'>; esi = argv</span>
      <span style='color:#800000;font-weight:bold;'>lodsd</span>
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>ebx</span>       <span style='color:#696969;'>; ebx = msg</span>
      <span style='color:#800000;font-weight:bold;'>lodsd</span>
      <span style='color:#800000;font-weight:bold;'>cdq</span>                    <span style='color:#696969;'>; ctr = 0, idx = 0, </span>
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>ecx</span>       <span style='color:#696969;'>; ecx = msglen</span>
      <span style='color:#800000;font-weight:bold;'>lodsd</span>
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>edi</span>       <span style='color:#696969;'>; edi = tag</span>
      <span style='color:#800000;font-weight:bold;'>lodsd</span>
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>ebp</span>       <span style='color:#696969;'>; ebp = mkey      </span>
      <span style='color:#800000;font-weight:bold;'>pushad</span>                 <span style='color:#696969;'>; allocate N-bytes for M</span>
      <span style='color:#696969;'>; zero initialize T</span>
      <span style='color:#800000;font-weight:bold;'>mov</span>     <span style='color:#808030;'>[</span><span style='color:#000080;'>edi</span><span style='color:#808030;'>+</span><span style='color:#008c00;'>0</span><span style='color:#808030;'>]</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>edx</span>   <span style='color:#696969;'>; t-&gt;w[0] = 0;</span>
      <span style='color:#800000;font-weight:bold;'>mov</span>     <span style='color:#808030;'>[</span><span style='color:#000080;'>edi</span><span style='color:#808030;'>+</span><span style='color:#008c00;'>4</span><span style='color:#808030;'>]</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>edx</span>   <span style='color:#696969;'>; t-&gt;w[1] = 0;</span>
      <span style='color:#696969;'>; while we have msg data</span>
<span style='color:#e34adc;'>lmx_l0:</span>
      <span style='color:#800000;font-weight:bold;'>mov</span>     <span style='color:#000080;'>esi</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>esp</span>       <span style='color:#696969;'>; esi = M</span>
      <span style='color:#800000;font-weight:bold;'>jecxz</span>   <span style='color:#e34adc;'>lmx_l2</span>         <span style='color:#696969;'>; exit loop if msglen == 0</span>
<span style='color:#e34adc;'>lmx_l1:</span>
      <span style='color:#696969;'>; add byte to M</span>
      <span style='color:#800000;font-weight:bold;'>mov</span>     <span style='color:#000080;'>al</span><span style='color:#808030;'>,</span> <span style='color:#808030;'>[</span><span style='color:#000080;'>ebx</span><span style='color:#808030;'>]</span>      <span style='color:#696969;'>; al = *data++</span>
      <span style='color:#800000;font-weight:bold;'>inc</span>     <span style='color:#000080;'>ebx</span>
      <span style='color:#800000;font-weight:bold;'>mov</span>     <span style='color:#808030;'>[</span><span style='color:#000080;'>esi</span><span style='color:#808030;'>+</span><span style='color:#000080;'>edx</span><span style='color:#808030;'>+</span>COUNTER_LENGTH<span style='color:#808030;'>]</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>al</span>           
      <span style='color:#800000;font-weight:bold;'>inc</span>     <span style='color:#000080;'>edx</span>            <span style='color:#696969;'>; idx++</span>
      <span style='color:#696969;'>; M filled?</span>
      <span style='color:#800000;font-weight:bold;'>cmp</span>     <span style='color:#000080;'>dl</span><span style='color:#808030;'>,</span> BLOCK_LENGTH <span style='color:#808030;'>-</span> COUNTER_LENGTH
      <span style='color:#696969;'>; --msglen</span>
      <span style='color:#800000;font-weight:bold;'>loopne</span>  <span style='color:#e34adc;'>lmx_l1</span>
      <span style='color:#800000;font-weight:bold;'>jne</span>     <span style='color:#e34adc;'>lmx_l2</span>
      <span style='color:#696969;'>; add S counter in big endian format</span>
      <span style='color:#800000;font-weight:bold;'>inc</span>     <span style='color:#800000;font-weight:bold;'>dword</span><span style='color:#808030;'>[</span><span style='color:#000080;'>esp</span><span style='color:#808030;'>+</span>_edx<span style='color:#808030;'>]</span><span style='color:#696969;'>; ctr++</span>
      <span style='color:#800000;font-weight:bold;'>mov</span>     <span style='color:#000080;'>eax</span><span style='color:#808030;'>,</span> <span style='color:#808030;'>[</span><span style='color:#000080;'>esp</span><span style='color:#808030;'>+</span>_edx<span style='color:#808030;'>]</span>
      <span style='color:#696969;'>; reset index</span>
      <span style='color:#800000;font-weight:bold;'>cdq</span>                    <span style='color:#696969;'>; idx = 0</span>
      <span style='color:#800000;font-weight:bold;'>bswap</span>   <span style='color:#000080;'>eax</span>            <span style='color:#696969;'>; m.ctr = SWAP32(ctr)</span>
      <span style='color:#800000;font-weight:bold;'>mov</span>     <span style='color:#808030;'>[</span><span style='color:#000080;'>esi</span><span style='color:#808030;'>]</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>eax</span>
      <span style='color:#696969;'>; encrypt M with E using K1</span>
      <span style='color:#800000;font-weight:bold;'>call</span>    <span style='color:#e34adc;'>ENCRYPT</span>
      <span style='color:#696969;'>; update T</span>
      <span style='color:#800000;font-weight:bold;'>lodsd</span>                  <span style='color:#696969;'>; t-&gt;w[0] ^= m.w[0];</span>
      <span style='color:#800000;font-weight:bold;'>xor</span>     <span style='color:#808030;'>[</span><span style='color:#000080;'>edi</span><span style='color:#808030;'>+</span><span style='color:#008c00;'>0</span><span style='color:#808030;'>]</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>eax</span>      
      <span style='color:#800000;font-weight:bold;'>lodsd</span>                  <span style='color:#696969;'>; t-&gt;w[1] ^= m.w[1];</span>
      <span style='color:#800000;font-weight:bold;'>xor</span>     <span style='color:#808030;'>[</span><span style='color:#000080;'>edi</span><span style='color:#808030;'>+</span><span style='color:#008c00;'>4</span><span style='color:#808030;'>]</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>eax</span>         
      <span style='color:#800000;font-weight:bold;'>jmp</span>     <span style='color:#e34adc;'>lmx_l0</span>         <span style='color:#696969;'>; keep going</span>
<span style='color:#e34adc;'>lmx_l2:</span>
      <span style='color:#696969;'>; add the end bit</span>
      <span style='color:#800000;font-weight:bold;'>mov</span>     <span style='color:#800000;font-weight:bold;'>byte</span><span style='color:#808030;'>[</span><span style='color:#000080;'>esi</span><span style='color:#808030;'>+</span><span style='color:#000080;'>edx</span><span style='color:#808030;'>+</span>COUNTER_LENGTH<span style='color:#808030;'>]</span><span style='color:#808030;'>,</span> <span style='color:#008000;'>0x80</span>
      <span style='color:#800000;font-weight:bold;'>xchg</span>    <span style='color:#000080;'>esi</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>edi</span>       <span style='color:#696969;'>; swap T and M</span>
<span style='color:#e34adc;'>lmx_l3:</span>
      <span style='color:#696969;'>; update T with any msg data remaining    </span>
      <span style='color:#800000;font-weight:bold;'>mov</span>     <span style='color:#000080;'>al</span><span style='color:#808030;'>,</span> <span style='color:#808030;'>[</span><span style='color:#000080;'>edi</span><span style='color:#808030;'>+</span><span style='color:#000080;'>edx</span><span style='color:#808030;'>+</span>COUNTER_LENGTH<span style='color:#808030;'>]</span>
      <span style='color:#800000;font-weight:bold;'>xor</span>     <span style='color:#808030;'>[</span><span style='color:#000080;'>esi</span><span style='color:#808030;'>+</span><span style='color:#000080;'>edx</span><span style='color:#808030;'>]</span><span style='color:#808030;'>,</span> <span style='color:#000080;'>al</span>
      <span style='color:#800000;font-weight:bold;'>dec</span>     <span style='color:#000080;'>edx</span>
      <span style='color:#800000;font-weight:bold;'>jns</span>     <span style='color:#e34adc;'>lmx_l3</span>
      <span style='color:#696969;'>; advance key to K2</span>
      <span style='color:#800000;font-weight:bold;'>add</span>     <span style='color:#000080;'>ebp</span><span style='color:#808030;'>,</span> BC_KEY_LENGTH
      <span style='color:#696969;'>; encrypt T with E using K2</span>
      <span style='color:#800000;font-weight:bold;'>call</span>    <span style='color:#e34adc;'>ENCRYPT</span>
      <span style='color:#800000;font-weight:bold;'>popad</span>                  <span style='color:#696969;'>; release memory for M</span>
      <span style='color:#800000;font-weight:bold;'>popad</span>                  <span style='color:#696969;'>; restore registers</span>
      <span style='color:#800000;font-weight:bold;'>ret</span>
</pre>

<h3>Summary</h3>

The x86 assembly generated by MSVC using /O2 /Os is 238 bytes. The x86 assembly written by hand is 152 bytes.

In order for developers to benefit from LightMAC on microcontrollers, they should choose a lightweight block cipher but not necessarily SPECK. It's only used here for illustration.

See <a href="https://github.com/odzhan/tinycrypt/tree/master/mac/lightmac">lmx32.asm and lightmac.c</a> for any future updates.
