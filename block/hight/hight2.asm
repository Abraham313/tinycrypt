; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\hub\tinycrypt\block\hight\hight2.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_hight128_setkey
PUBLIC	_hight128_encrypt
PUBLIC	_gen_const
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\hight\hight2.c
;	COMDAT _gen_const
_TEXT	SEGMENT
_s$ = -20						; size = 136
_ci$ = 124						; size = 4
_gen_const PROC						; COMDAT

; 54   : {

	push	ebp
	lea	ebp, DWORD PTR [esp-116]
	sub	esp, 136				; 00000088H

; 55   :     int     i, j;
; 56   :     uint8_t c;
; 57   :     
; 58   :     union {
; 59   :       uint8_t  b[128+8];
; 60   :       uint32_t w[(128+8)/4];
; 61   :     } s;
; 62   : 
; 63   :     // zero initialize s
; 64   :     memset(&s, 0, sizeof(s));
; 65   : 
; 66   :     // set initial bits
; 67   :     s.w[1] = 65537;
; 68   :     s.w[0] = s.w[1] << 8;
; 69   : 
; 70   :     // set first constant
; 71   :     // calculated from bits of s array
; 72   :     ci[0] = 0x5A;

	mov	edx, DWORD PTR _ci$[ebp]
	xor	al, al
	push	esi
	push	edi
	lea	edi, DWORD PTR _s$[ebp]
	mov	ecx, 136				; 00000088H
	rep stosb

; 73   : 
; 74   :     for(i=1; i<128; i++) {

	xor	eax, eax
	mov	DWORD PTR _s$[ebp+4], 65537		; 00010001H
	mov	DWORD PTR _s$[ebp], 16777472		; 01000100H
	inc	eax
	mov	BYTE PTR [edx], 90			; 0000005aH
$LL4@gen_const:

; 75   :       c = s.b[i + 2] ^

	mov	cl, BYTE PTR _s$[ebp+eax-1]
	lea	esi, DWORD PTR _s$[ebp+eax+5]
	xor	cl, BYTE PTR _s$[ebp+eax+2]
	push	6

; 76   :           s.b[i - 1];
; 77   : 
; 78   :       s.b[i + 6] = c;

	mov	BYTE PTR _s$[ebp+eax+6], cl
	pop	edi
$LL7@gen_const:

; 79   : 
; 80   :       for(j=1; j<7; j++) {
; 81   :         c += c;

	add	cl, cl

; 82   :         c ^= s.b[i + 6 - j];

	xor	cl, BYTE PTR [esi]
	dec	esi
	sub	edi, 1
	jne	SHORT $LL7@gen_const

; 83   :       }
; 84   :       ci[i] = c;

	mov	BYTE PTR [eax+edx], cl
	inc	eax
	cmp	eax, 128				; 00000080H
	jl	SHORT $LL4@gen_const
	pop	edi
	pop	esi

; 85   :     }
; 86   : }

	lea	esp, DWORD PTR [ebp+116]
	pop	ebp
	ret	0
_gen_const ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\hight\hight2.c
;	COMDAT _hight128_encrypt
_TEXT	SEGMENT
_sk$1$ = -16						; size = 4
tv780 = -12						; size = 4
tv775 = -8						; size = 4
tv772 = -4						; size = 4
tv779 = 8						; size = 4
_data$ = 8						; size = 4
_keys$ = 12						; size = 4
_hight128_encrypt PROC					; COMDAT

; 124  : {

	sub	esp, 16					; 00000010H
	push	ebx

; 125  :     uint8_t  c, i, j;
; 126  :     w64_t    *x;
; 127  :     uint8_t  *sk, *wk=(uint8_t*)keys;
; 128  :     uint8_t  *p;
; 129  :     
; 130  :     x  = (w64_t*)data;
; 131  :     sk = &wk[8];

	mov	ebx, DWORD PTR _keys$[esp+16]
	push	ebp
	push	esi
	push	edi

; 132  : 
; 133  :     // mix key with 1st 4 bytes
; 134  :     x->b[0] += wk[0]; x->b[2] ^= wk[1];

	mov	edi, DWORD PTR _data$[esp+28]
	lea	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _sk$1$[esp+32], eax
	mov	al, BYTE PTR [ebx]
	push	2
	add	BYTE PTR [edi], al
	lea	ebp, DWORD PTR [edi+2]
	mov	al, BYTE PTR [ebx+1]
	xor	BYTE PTR [ebp], al

; 135  :     x->b[4] += wk[2]; x->b[6] ^= wk[3];

	mov	al, BYTE PTR [ebx+2]
	add	BYTE PTR [edi+4], al
	mov	al, BYTE PTR [ebx+3]
	xor	BYTE PTR [edi+6], al
	pop	eax
	push	32					; 00000020H
	sub	eax, edi
	pop	ebx
	mov	DWORD PTR tv772[esp+32], eax
	mov	DWORD PTR tv780[esp+32], ebx
$LL4@hight128_e:

; 138  :       x->q = ROTL64(x->q, 8);

	mov	edx, DWORD PTR [edi+4]
	xor	eax, eax
	mov	esi, DWORD PTR [edi]
	mov	ecx, edx
	mov	ebx, DWORD PTR tv772[esp+32]
	shld	edx, esi, 8
	shr	ecx, 24					; 00000018H
	shl	esi, 8
	or	ecx, esi
	mov	DWORD PTR tv775[esp+32], ebp
	mov	esi, DWORD PTR _sk$1$[esp+32]
	or	eax, edx
	mov	DWORD PTR [edi], ecx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR tv779[esp+28], 2
$LL7@hight128_e:

; 139  :       // apply linear/non-linear operations      
; 140  :       for (j=2; j<8; j+=4) {
; 141  :         c = x->b[j-1];

	or	eax, -1
	mov	cl, BYTE PTR [eax+ebp]

; 142  :         c = ROTL8(c, 3) ^ ROTL8(c, 4) ^ ROTL8(c, 6);

	mov	al, cl
	mov	dl, cl
	rol	dl, 4
	rol	al, 3

; 143  :         x->b[j] += c ^ *sk++;

	xor	dl, al
	ror	cl, 2
	xor	dl, cl

; 144  :         
; 145  :         c = x->b[j+1];

	xor	eax, eax
	xor	dl, BYTE PTR [esi]
	add	BYTE PTR [ebp], dl
	inc	esi
	mov	DWORD PTR _sk$1$[esp+32], esi

; 146  :         c = ROTL8(c, 1) ^ ROTL8(c, 2) ^ ROTL8(c, 7);        
; 147  :         x->b[(j+2)&7] ^= (c + *sk++);

	lea	esi, DWORD PTR [ebx+ebp]
	mov	dl, BYTE PTR [eax+ebp+1]
	lea	ebp, DWORD PTR [ebp+4]
	mov	al, dl
	mov	cl, dl
	rol	cl, 2
	and	esi, 7
	ror	al, 1
	xor	cl, al
	rol	dl, 1
	mov	eax, DWORD PTR _sk$1$[esp+32]
	xor	cl, dl
	add	cl, BYTE PTR [eax]
	xor	BYTE PTR [esi+edi], cl
	mov	esi, eax
	inc	esi
	sub	DWORD PTR tv779[esp+28], 1
	mov	DWORD PTR _sk$1$[esp+32], esi
	jne	SHORT $LL7@hight128_e

; 136  : 
; 137  :     for (i=0; i<32; i++) {

	sub	DWORD PTR tv780[esp+32], 1
	lea	ebp, DWORD PTR [edi+2]
	jne	$LL4@hight128_e

; 148  :       }      
; 149  :     }
; 150  :     // unnecessary IMHO, but it's part of the spec
; 151  :     x->q = ROTL64(x->q, 56);  

	mov	esi, DWORD PTR [edi]
	xor	eax, eax
	mov	edx, DWORD PTR [edi+4]
	mov	ecx, esi

; 152  :     
; 153  :     x->b[0] += wk[4]; x->b[2] ^= wk[5];

	mov	ebx, DWORD PTR _keys$[esp+28]
	shrd	esi, edx, 8
	shl	ecx, 24					; 00000018H
	or	eax, esi
	shr	edx, 8
	mov	DWORD PTR [edi], eax
	or	ecx, edx
	mov	DWORD PTR [edi+4], ecx
	mov	al, BYTE PTR [ebx+4]
	add	BYTE PTR [edi], al
	mov	al, BYTE PTR [ebx+5]
	xor	BYTE PTR [ebp], al

; 154  :     x->b[4] += wk[6]; x->b[6] ^= wk[7];

	mov	al, BYTE PTR [ebx+6]
	add	BYTE PTR [edi+4], al
	mov	al, BYTE PTR [ebx+7]
	xor	BYTE PTR [edi+6], al
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 155  : }

	add	esp, 16					; 00000010H
	ret	0
_hight128_encrypt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\hight\hight2.c
;	COMDAT _hight128_setkey
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_hight128_setkey PROC					; COMDAT

; 90   : {

	push	ebx
	push	esi

; 91   :     uint8_t i, j, idx;
; 92   :     w128_t  *wk, *mk;
; 93   :     uint8_t *sk;
; 94   :     
; 95   :     mk=(w128_t*)in;
; 96   :     wk=(w128_t*)out;
; 97   :     sk=(uint8_t*)out;

	mov	esi, DWORD PTR _out$[esp+4]
	push	edi

; 98   :     
; 99   :     // apply key whitening
; 100  :     wk->w[0] = mk->w[3];

	mov	edi, DWORD PTR _in$[esp+8]
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], eax

; 101  :     wk->w[1] = mk->w[0];

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax

; 102  : 
; 103  :     #ifdef LUT
; 104  :       memcpy(&sk[8], rc, sizeof(rc));
; 105  :     #else  
; 106  :       // generate constants
; 107  :       gen_const(&sk[8]);

	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	_gen_const
	pop	ecx

; 108  :     #endif
; 109  :  
; 110  :     // generate subkeys
; 111  :     for(i=0; i<8; i++) {

	xor	dl, dl
$LL4@hight128_s:

; 112  :       sk += 8;

	add	esi, 8

; 113  :       for(j=0; j<8; j++) {

	xor	bl, bl
$LL7@hight128_s:

; 114  :         idx = (j - i + 8) & 7;

	mov	cl, bl
	sub	cl, dl
	and	ecx, 7

; 115  : 
; 116  :         sk[0] += mk->b[idx  ];

	mov	al, BYTE PTR [ecx+edi]
	add	BYTE PTR [esi], al

; 117  :         sk[8] += mk->b[idx+8];

	mov	al, BYTE PTR [edi+ecx+8]
	add	BYTE PTR [esi+8], al

; 118  :         sk++;        

	inc	esi
	inc	bl
	cmp	bl, 8
	jb	SHORT $LL7@hight128_s

; 108  :     #endif
; 109  :  
; 110  :     // generate subkeys
; 111  :     for(i=0; i<8; i++) {

	inc	dl
	cmp	dl, 8
	jb	SHORT $LL4@hight128_s

; 119  :       }
; 120  :     }
; 121  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
_hight128_setkey ENDP
_TEXT	ENDS
END
