; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	c:\hub\tinycrypt\block\aes\aes2.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_aes_enc
PUBLIC	_aes_setkey
PUBLIC	_XT
PUBLIC	_SubByte
PUBLIC	_SubWord
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes2.c
;	COMDAT _SubWord
_TEXT	SEGMENT
_r$ = 8							; size = 4
_x$ = 8							; size = 4
_SubWord PROC						; COMDAT

; 77   : {

	push	ebp
	mov	ebp, esp

; 78   :     int   i;
; 79   :     w32_t r;
; 80   : 
; 81   :     r.w = x;

	mov	eax, DWORD PTR _x$[ebp]
	push	esi
	mov	DWORD PTR _r$[ebp], eax

; 82   :     
; 83   :     for (i=0; i<4; i++) {

	xor	esi, esi
$LL4@SubWord:

; 84   :       r.b[i] = SubByte(r.b[i]);

	movzx	eax, BYTE PTR _r$[ebp+esi]
	push	eax
	call	_SubByte
	mov	BYTE PTR _r$[ebp+esi], al
	inc	esi
	pop	ecx
	cmp	esi, 4
	jl	SHORT $LL4@SubWord

; 85   :     }
; 86   :     return r.w;

	mov	eax, DWORD PTR _r$[ebp]
	pop	esi

; 87   : }

	pop	ebp
	ret	0
_SubWord ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes2.c
;	COMDAT _SubByte
_TEXT	SEGMENT
_x$ = 8							; size = 1
_y$1$ = 11						; size = 1
_SubByte PROC						; COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 46   :     uint8_t i, y=x, sb;

	mov	bl, BYTE PTR _x$[ebp]

; 47   :     
; 48   : // ------------------------------------
; 49   : // multiplicative inverse
; 50   : // ------------------------------------
; 51   :     
; 52   :     if (x) {

	test	bl, bl
	je	SHORT $LN6@SubByte

; 53   :       // calculate logarithm gen 3
; 54   :       for (i=1, y=1; i > 0; i++) {

	mov	bh, 1
	mov	cl, bh
	mov	BYTE PTR _y$1$[ebp], cl
$LL4@SubByte:

; 55   :         y ^= XT(y);

	movzx	eax, cl
	push	eax
	call	_XT
	pop	ecx
	mov	cl, BYTE PTR _y$1$[ebp]
	xor	cl, al
	mov	BYTE PTR _y$1$[ebp], cl

; 56   :         if (y == x) break;

	cmp	cl, bl
	je	SHORT $LN17@SubByte

; 53   :       // calculate logarithm gen 3
; 54   :       for (i=1, y=1; i > 0; i++) {

	add	bh, 1
	jne	SHORT $LL4@SubByte
$LN17@SubByte:

; 57   :       }
; 58   :       x = ~i;

	not	bh

; 59   :       // calculate anti-logarithm gen 3
; 60   :       for (i=0, y=1; i < x; i++) {

	mov	bl, 1
	test	bh, bh
	je	SHORT $LN6@SubByte

; 57   :       }
; 58   :       x = ~i;

	push	esi
	movzx	esi, bh
$LL7@SubByte:

; 61   :         y ^= XT(y);

	movzx	eax, bl
	push	eax
	call	_XT
	xor	bl, al
	pop	ecx
	sub	esi, 1
	jne	SHORT $LL7@SubByte
	pop	esi
$LN6@SubByte:

; 62   :       }
; 63   :     }
; 64   :     
; 65   :     sb = y;

	push	4
	mov	al, bl
	pop	ecx
$LL10@SubByte:

; 66   : 
; 67   :     for (i=0; i<4; i++) {
; 68   :       y   = ROTL8(y, 1);

	rol	bl, 1

; 69   :       sb ^= y;

	xor	al, bl
	sub	ecx, 1
	jne	SHORT $LL10@SubByte

; 70   :     }
; 71   :     return sb ^ 0x63;

	xor	al, 99					; 00000063H
	pop	ebx

; 72   : }

	pop	ebp
	ret	0
_SubByte ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes2.c
;	COMDAT _XT
_TEXT	SEGMENT
_w$ = 8							; size = 4
_XT	PROC						; COMDAT

; 36   :     uint32_t t = w & 0x80808080;

	mov	ecx, DWORD PTR _w$[esp-4]
	and	ecx, -2139062144			; 80808080H

; 37   :     
; 38   :     return ( (w ^ t ) << 1) ^ ( ( t >> 7) * 0x0000001B);

	mov	eax, ecx
	shr	ecx, 7
	xor	eax, DWORD PTR _w$[esp-4]
	imul	ecx, ecx, 27
	add	eax, eax
	xor	eax, ecx

; 39   : }

	ret	0
_XT	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes2.c
;	COMDAT _aes_setkey
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_key$ = 12						; size = 4
_aes_setkey PROC					; COMDAT

; 93   : {

	push	ebx

; 94   :     int      i;
; 95   :     uint32_t x;
; 96   :     uint32_t *w=(uint32_t*)ctx->w;
; 97   :     uint32_t rcon=1;
; 98   : 
; 99   :     memcpy(w, key, Nk*4);

	mov	ebx, DWORD PTR _ctx$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _key$[esp+8]
	push	edi
	push	8
	pop	ebp
	mov	ecx, ebp
	mov	edi, ebx
	rep movsd
	xor	edi, edi
	inc	edi
$LL4@aes_setkey:

; 100  : 
; 101  :     for (i=Nk; i<Nb*(Nr+1); i++)
; 102  :     {
; 103  :       x = w[i-1];

	mov	esi, DWORD PTR [ebx+28]

; 104  :       if ((i % Nk)==0) {

	mov	eax, ebp
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN13@aes_setkey
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN13@aes_setkey:
	jne	SHORT $LN5@aes_setkey

; 105  :         x = RotWord(x);

	ror	esi, 8

; 106  :         x = SubWord(x) ^ rcon;

	push	esi
	call	_SubWord
	mov	esi, eax

; 107  :         rcon=XT(rcon);

	push	edi
	xor	esi, edi
	call	_XT
	pop	ecx
	mov	edi, eax
	jmp	SHORT $LN14@aes_setkey
$LN5@aes_setkey:

; 108  :       } else if ((i % Nk) == 4) {

	cmp	eax, 4
	jne	SHORT $LN7@aes_setkey

; 109  :         x = SubWord(x);

	push	esi
	call	_SubWord
	mov	esi, eax
$LN14@aes_setkey:
	pop	ecx
$LN7@aes_setkey:

; 110  :       }
; 111  :       w[i] = w[i-Nk] ^ x;

	mov	ecx, DWORD PTR [ebx]
	xor	ecx, esi
	inc	ebp
	mov	DWORD PTR [ebx+32], ecx
	add	ebx, 4
	cmp	ebp, 60					; 0000003cH
	jl	SHORT $LL4@aes_setkey

; 112  :     }
; 113  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
_aes_setkey ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes2.c
;	COMDAT _aes_enc
_TEXT	SEGMENT
tv404 = -260						; size = 4
_v$ = -256						; size = 16
_rk$ = -240						; size = 240
_data$ = 8						; size = 4
_key$ = 12						; size = 4
_aes_enc PROC						; COMDAT

; 115  : void aes_enc (void *data, void *key) {

	sub	esp, 260				; 00000104H

; 116  :     w128_t   *x, *k, v;
; 117  :     uint32_t i, w, r;
; 118  :     uint32_t rk[Nb*(Nr+1)];
; 119  :     
; 120  :     x=(w128_t*)data;
; 121  :     k=(w128_t*)rk;
; 122  :     
; 123  :     // initialize round keys
; 124  :     aes_setkey((aes_ctx*)&rk, key);

	lea	eax, DWORD PTR _rk$[esp+260]
	push	ebx
	push	ebp
	push	esi
	push	edi
	push	DWORD PTR _key$[esp+272]
	push	eax
	call	_aes_setkey

; 125  :     
; 126  :     // copy data to local buffer
; 127  :     memcpy (&v, x, 16);

	mov	ebp, DWORD PTR _data$[esp+280]
	lea	edi, DWORD PTR _v$[esp+284]
	mov	esi, ebp
	lea	edx, DWORD PTR _rk$[esp+284]
	pop	ecx
	pop	ecx

; 128  :     r = 0;

	xor	ebx, ebx
	movsd
	movsd
	movsd
	movsd
$add_key$35:

; 143  :                    ROTR32(w, 16) ^ 
; 144  :                    ROTR32(w, 24) ^ 
; 145  :                 XT(ROTR32(w,  8) ^ w);
; 146  :         }
; 147  :       }
; 148  : add_key:    
; 149  :       // add round key
; 150  :       for (i=0; i<4; i++) {

	xor	ecx, ecx
$LL13@aes_enc:

; 151  :         x->w[i] = v.w[i] ^ k->w[i];

	mov	eax, DWORD PTR [edx+ecx*4]
	xor	eax, DWORD PTR _v$[esp+ecx*4+276]
	mov	DWORD PTR [ebp+ecx*4], eax
	inc	ecx
	cmp	ecx, 4
	jb	SHORT $LL13@aes_enc

; 152  :       }
; 153  :       k++;    

	add	edx, 16					; 00000010H

; 154  :     } while (++r <= Nr);

	inc	ebx
	mov	DWORD PTR tv404[esp+276], edx
	cmp	ebx, 14					; 0000000eH
	ja	SHORT $LN22@aes_enc

; 129  :     goto add_key;
; 130  :     
; 131  :     do { 
; 132  :       // apply sub bytes and shift rows
; 133  :       for (i=0; i<16; i++) {     

	xor	edi, edi
$LL7@aes_enc:

; 134  :         v.m[((i >> 2) + 4 - (i & 3) ) & 3][i & 3] = SubByte(x->b[i]);

	movzx	eax, BYTE PTR [edi+ebp]
	mov	esi, edi
	push	eax
	and	esi, 3
	call	_SubByte
	pop	ecx
	mov	ecx, edi
	shr	ecx, 2
	sub	ecx, esi
	and	ecx, 3
	inc	edi
	lea	ecx, DWORD PTR [esi+ecx*4]
	mov	BYTE PTR _v$[esp+ecx+276], al
	cmp	edi, 16					; 00000010H
	jb	SHORT $LL7@aes_enc

; 135  :       }
; 136  :     
; 137  :       // if not last round
; 138  :       if (r != Nr) {

	mov	edx, DWORD PTR tv404[esp+276]
	cmp	ebx, 14					; 0000000eH
	je	SHORT $add_key$35

; 139  :         // mix columns
; 140  :         for (i=0; i<4; i++) {

	xor	ebp, ebp
$LL10@aes_enc:

; 141  :           w = v.w[i];

	mov	esi, DWORD PTR _v$[esp+ebp*4+276]

; 142  :           v.w[i] = ROTR32(w,  8) ^ 

	mov	edi, esi
	ror	edi, 8
	mov	eax, edi
	xor	eax, esi
	push	eax
	call	_XT
	pop	ecx
	mov	ecx, esi
	rol	esi, 8
	rol	ecx, 16					; 00000010H
	xor	eax, ecx
	xor	eax, esi
	xor	eax, edi
	mov	DWORD PTR _v$[esp+ebp*4+276], eax
	inc	ebp
	cmp	ebp, 4
	jb	SHORT $LL10@aes_enc

; 143  :                    ROTR32(w, 16) ^ 
; 144  :                    ROTR32(w, 24) ^ 
; 145  :                 XT(ROTR32(w,  8) ^ w);
; 146  :         }
; 147  :       }
; 148  : add_key:    
; 149  :       // add round key
; 150  :       for (i=0; i<4; i++) {

	mov	edx, DWORD PTR tv404[esp+276]
	mov	ebp, DWORD PTR _data$[esp+272]
	jmp	$add_key$35
$LN22@aes_enc:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 155  : }

	add	esp, 260				; 00000104H
	ret	0
_aes_enc ENDP
_TEXT	ENDS
END
