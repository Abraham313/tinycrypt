; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\tinycrypt\hash\md6\ref\md6_compress.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_S0
PUBLIC	_Smask
_DATA	SEGMENT
COMM	_compression_hook:DWORD
_DATA	ENDS
CONST	SEGMENT
_S0	DQ	0123456789abcdefH
_Smask	DQ	7311c2812425cfa0H
CONST	ENDS
PUBLIC	_md6_main_compression_loop
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\hash\md6\ref\md6_compress.c
;	COMDAT _md6_main_compression_loop
_TEXT	SEGMENT
tv5367 = -84						; size = 8
tv5607 = -76						; size = 8
tv5623 = -68						; size = 8
tv5639 = -60						; size = 8
tv4626 = -52						; size = 8
tv5257 = -44						; size = 8
tv5074 = -36						; size = 8
tv4923 = -28						; size = 8
tv4900 = -20						; size = 8
_S$ = -12						; size = 8
tv5345 = -4						; size = 4
_A$ = 8							; size = 4
tv4624 = 12						; size = 4
_r$ = 12						; size = 4
_md6_main_compression_loop PROC				; COMDAT

; 206  : { md6_word x, S;

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 213  :   for (j = 0, i = n; j<r*c; j+=c)

	mov	ecx, DWORD PTR _r$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _S$[ebp], -1985229329		; 89abcdefH
	mov	DWORD PTR _S$[ebp+4], 19088743		; 01234567H
	test	ecx, ecx
	jle	$LN1@md6_main_c

; 207  :   int i,j;
; 208  : 
; 209  :   /*
; 210  :   ** main computation loop for md6 compression
; 211  :   */
; 212  :   S = S0;

	mov	eax, DWORD PTR _A$[ebp]
	add	eax, 464				; 000001d0H
	dec	ecx
	push	ebx
	shr	ecx, 4
	inc	ecx
	push	esi
	mov	DWORD PTR tv5345[ebp], ecx
	push	edi
$LL3@md6_main_c:

; 214  :     {
; 215  : 
; 216  : /* ***************************************************************** */
; 217  : #define loop_body(rs,ls,step)                                       \
; 218  :       x = S;                                /* feedback constant     */ \
; 219  :       x ^= A[i+step-t5];                    /* end-around feedback   */ \
; 220  :       x ^= A[i+step-t0];                    /* linear feedback       */ \
; 221  :       x ^= ( A[i+step-t1] & A[i+step-t2] ); /* first quadratic term  */ \
; 222  :       x ^= ( A[i+step-t3] & A[i+step-t4] ); /* second quadratic term */ \
; 223  :       x ^= (x >> rs);                       /* right-shift           */ \
; 224  :       A[i+step] = x ^ (x << ls);            /* left-shift            */   
; 225  : /* ***************************************************************** */
; 226  : 
; 227  :       /*
; 228  :       ** Unroll loop c=16 times. (One "round" of computation.)
; 229  :       ** Shift amounts are embedded in macros RLnn.
; 230  :       */
; 231  :       RL00 RL01 RL02 RL03 RL04 RL05 RL06 RL07

	mov	edx, DWORD PTR [eax-284]
	and	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+108]
	and	edi, DWORD PTR [eax+84]
	mov	ebx, DWORD PTR [eax+104]
	and	ebx, DWORD PTR [eax+80]
	mov	ecx, DWORD PTR [eax-288]
	and	ecx, DWORD PTR [eax]
	xor	edx, edi
	xor	edx, DWORD PTR [eax-460]
	xor	ecx, ebx
	xor	ecx, DWORD PTR [eax-464]
	xor	edx, DWORD PTR [eax+116]
	mov	esi, DWORD PTR [eax+112]
	xor	edx, DWORD PTR _S$[ebp+4]
	xor	ecx, esi
	xor	ecx, DWORD PTR _S$[ebp]
	mov	ebx, edx
	mov	edi, ecx
	shrd	edi, ebx, 10
	xor	ecx, edi
	and	esi, DWORD PTR [eax+88]
	shr	ebx, 10					; 0000000aH
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 11
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-276]
	and	edx, DWORD PTR [eax+12]
	shl	edi, 11					; 0000000bH
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax-280]
	and	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+252], ebx
	mov	ebx, DWORD PTR [eax+116]
	and	ebx, DWORD PTR [eax+92]
	xor	ecx, esi
	xor	ecx, DWORD PTR [eax-456]
	mov	esi, DWORD PTR [eax+124]
	xor	ecx, DWORD PTR [eax+120]
	xor	edx, ebx
	xor	edx, DWORD PTR [eax-452]
	xor	ecx, DWORD PTR _S$[ebp]
	xor	edx, esi
	xor	edx, DWORD PTR _S$[ebp+4]
	mov	DWORD PTR [eax+248], edi
	mov	edi, ecx
	mov	ebx, edx
	shrd	edi, ebx, 5
	xor	ecx, edi
	shr	ebx, 5
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 24
	shl	edi, 24					; 00000018H
	xor	edi, ecx
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-268]
	and	edx, DWORD PTR [eax+20]
	lea	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR tv4624[ebp], ecx
	mov	ecx, DWORD PTR [eax-272]
	and	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [eax+256], edi
	mov	edi, DWORD PTR [eax+96]
	and	edi, DWORD PTR [eax+120]
	mov	DWORD PTR [eax+260], ebx
	mov	ebx, DWORD PTR [eax+100]
	and	ebx, esi
	mov	esi, DWORD PTR tv4624[ebp]
	xor	ecx, edi
	xor	ecx, DWORD PTR [eax-448]
	mov	edi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	xor	edx, ebx
	xor	edx, DWORD PTR [eax-444]
	xor	ecx, edi
	mov	DWORD PTR tv4626[ebp+4], esi
	xor	edx, esi
	xor	ecx, DWORD PTR _S$[ebp]
	xor	edx, DWORD PTR _S$[ebp+4]
	mov	esi, ecx
	mov	ebx, edx
	shrd	esi, ebx, 13
	xor	ecx, esi
	shr	ebx, 13					; 0000000dH
	xor	edx, ebx
	mov	esi, ecx
	mov	ebx, edx
	shld	ebx, esi, 9
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-260]
	and	edx, DWORD PTR [eax+28]
	shl	esi, 9
	xor	esi, ecx
	mov	ecx, DWORD PTR [eax-264]
	and	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+264], esi
	mov	esi, DWORD PTR [eax+104]
	and	esi, edi
	mov	edi, DWORD PTR [eax+108]
	and	edi, DWORD PTR tv4626[ebp+4]
	xor	ecx, esi
	xor	ecx, DWORD PTR [eax-440]
	mov	esi, DWORD PTR [eax+136]
	xor	edx, edi
	xor	edx, DWORD PTR [eax-436]
	xor	ecx, esi
	xor	edx, DWORD PTR [eax+140]
	xor	ecx, DWORD PTR _S$[ebp]
	xor	edx, DWORD PTR _S$[ebp+4]
	mov	DWORD PTR [eax+268], ebx
	mov	edi, ecx
	mov	ebx, edx
	shrd	edi, ebx, 10
	xor	ecx, edi
	shr	ebx, 10					; 0000000aH
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 16
	shl	edi, 16					; 00000010H
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax-256]
	and	ecx, DWORD PTR [eax+32]
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-252]
	and	edx, DWORD PTR [eax+36]
	mov	DWORD PTR [eax+272], edi
	mov	edi, DWORD PTR [eax+112]
	and	edi, esi
	mov	esi, DWORD PTR [eax+116]
	and	esi, DWORD PTR [eax+140]
	xor	ecx, edi
	xor	ecx, DWORD PTR [eax-432]
	xor	edx, esi
	xor	edx, DWORD PTR [eax-428]
	mov	esi, DWORD PTR [eax+144]
	xor	edx, DWORD PTR [eax+148]
	xor	ecx, esi
	xor	ecx, DWORD PTR _S$[ebp]
	xor	edx, DWORD PTR _S$[ebp+4]
	mov	DWORD PTR [eax+276], ebx
	mov	edi, ecx
	mov	ebx, edx
	shrd	edi, ebx, 11
	shr	ebx, 11					; 0000000bH
	xor	ecx, edi
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 15
	shl	edi, 15					; 0000000fH
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax-248]
	xor	ebx, edx
	and	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax-244]
	mov	DWORD PTR [eax+280], edi
	mov	DWORD PTR [eax+284], ebx
	and	edx, DWORD PTR [eax+44]
	mov	edi, DWORD PTR [eax+148]
	and	edi, DWORD PTR [eax+124]
	and	esi, DWORD PTR [eax+120]
	xor	edx, edi
	xor	edx, DWORD PTR [eax-420]
	xor	ecx, esi
	xor	ecx, DWORD PTR [eax-424]
	xor	edx, DWORD PTR [eax+156]
	mov	esi, DWORD PTR [eax+152]
	xor	edx, DWORD PTR _S$[ebp+4]
	xor	ecx, esi
	xor	ecx, DWORD PTR _S$[ebp]
	mov	ebx, edx
	mov	edi, ecx
	shrd	edi, ebx, 12
	xor	ecx, edi
	shr	ebx, 12					; 0000000cH
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 9
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-236]
	and	edx, DWORD PTR [eax+52]
	shl	edi, 9
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax-240]
	and	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [eax+292], ebx
	mov	ebx, DWORD PTR tv4624[ebp]
	mov	DWORD PTR [eax+288], edi
	mov	edi, esi
	and	edi, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax+156]
	and	ebx, DWORD PTR tv4626[ebp+4]
	xor	ecx, edi
	xor	ecx, DWORD PTR [eax-416]
	xor	edx, ebx
	xor	edx, DWORD PTR [eax-412]
	xor	ecx, DWORD PTR [eax+160]
	xor	edx, DWORD PTR [eax+164]
	xor	ecx, DWORD PTR _S$[ebp]
	xor	edx, DWORD PTR _S$[ebp+4]
	mov	edi, ecx
	mov	ebx, edx
	shrd	edi, ebx, 2
	xor	ecx, edi
	shr	ebx, 2
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 27
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-228]
	and	edx, DWORD PTR [eax+60]
	shl	edi, 27					; 0000001bH
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax-232]
	and	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [eax+296], edi
	mov	edi, DWORD PTR [eax+160]
	and	edi, DWORD PTR [eax+136]
	mov	DWORD PTR [eax+300], ebx
	mov	ebx, DWORD PTR [eax+164]
	and	ebx, DWORD PTR [eax+140]
	xor	ecx, edi
	xor	ecx, DWORD PTR [eax-408]
	xor	edx, ebx
	xor	edx, DWORD PTR [eax-404]
	xor	ecx, DWORD PTR [eax+168]
	xor	edx, DWORD PTR [eax+172]
	xor	ecx, DWORD PTR _S$[ebp]
	xor	edx, DWORD PTR _S$[ebp+4]
	mov	edi, ecx
	mov	ebx, edx
	shrd	edi, ebx, 7
	xor	ecx, edi
	shr	ebx, 7
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 15
	xor	ebx, edx

; 232  :       RL08 RL09 RL10 RL11 RL12 RL13 RL14 RL15

	mov	edx, DWORD PTR [eax-220]
	and	edx, DWORD PTR [eax+68]
	shl	edi, 15					; 0000000fH
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax+176]
	mov	DWORD PTR tv4900[ebp], ecx
	mov	ecx, DWORD PTR [eax+180]
	mov	DWORD PTR tv4900[ebp+4], ecx
	mov	ecx, DWORD PTR [eax-224]
	and	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [eax+304], edi
	mov	edi, DWORD PTR [eax+168]
	and	edi, DWORD PTR [eax+144]
	mov	DWORD PTR [eax+308], ebx
	mov	ebx, DWORD PTR [eax+172]
	and	ebx, DWORD PTR [eax+148]
	xor	ecx, edi
	xor	ecx, DWORD PTR [eax-400]
	xor	edx, ebx
	xor	edx, DWORD PTR [eax-396]
	xor	ecx, DWORD PTR tv4900[ebp]
	xor	edx, DWORD PTR tv4900[ebp+4]
	xor	ecx, DWORD PTR _S$[ebp]
	xor	edx, DWORD PTR _S$[ebp+4]
	mov	edi, ecx
	mov	ebx, edx
	shrd	edi, ebx, 14
	xor	ecx, edi
	shr	ebx, 14					; 0000000eH
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 6
	shl	edi, 6
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax-216]
	and	ecx, DWORD PTR [eax+72]
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-212]
	and	edx, DWORD PTR [eax+76]
	mov	DWORD PTR [eax+312], edi
	mov	edi, DWORD PTR tv4900[ebp]
	and	edi, esi
	mov	esi, DWORD PTR tv4900[ebp+4]
	and	esi, DWORD PTR [eax+156]
	xor	ecx, edi
	xor	ecx, DWORD PTR [eax-392]
	xor	edx, esi
	xor	edx, DWORD PTR [eax-388]
	xor	ecx, DWORD PTR [eax+184]
	xor	edx, DWORD PTR [eax+188]
	xor	ecx, DWORD PTR _S$[ebp]
	mov	esi, DWORD PTR _S$[ebp+4]
	mov	DWORD PTR [eax+316], ebx
	xor	edx, esi
	mov	edi, ecx
	mov	ebx, edx
	shrd	edi, ebx, 15
	shr	ebx, 15					; 0000000fH
	xor	ecx, edi
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 2
	shl	edi, 2
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax-208]
	and	ecx, DWORD PTR [eax+80]
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-204]
	and	edx, DWORD PTR [eax+84]
	mov	DWORD PTR [eax+320], edi
	mov	edi, DWORD PTR [eax+184]
	and	edi, DWORD PTR [eax+160]
	mov	DWORD PTR [eax+324], ebx
	mov	ebx, DWORD PTR [eax+188]
	and	ebx, DWORD PTR [eax+164]
	xor	ecx, edi
	xor	ecx, DWORD PTR [eax-384]
	xor	edx, ebx
	xor	edx, DWORD PTR [eax-380]
	xor	ecx, DWORD PTR [eax+192]
	xor	edx, DWORD PTR [eax+196]
	xor	ecx, DWORD PTR _S$[ebp]
	xor	edx, esi
	mov	edi, ecx
	mov	ebx, edx
	shrd	edi, ebx, 7
	xor	ecx, edi
	shr	ebx, 7
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 29
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-196]
	and	edx, DWORD PTR [eax+92]
	shl	edi, 29					; 0000001dH
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax-200]
	and	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR [eax+328], edi
	mov	edi, DWORD PTR [eax+192]
	and	edi, DWORD PTR [eax+168]
	mov	DWORD PTR [eax+332], ebx
	mov	ebx, DWORD PTR [eax+196]
	and	ebx, DWORD PTR [eax+172]
	xor	ecx, edi
	xor	ecx, DWORD PTR [eax-376]
	xor	edx, ebx
	xor	edx, DWORD PTR [eax-372]
	xor	ecx, DWORD PTR [eax+200]
	xor	edx, DWORD PTR [eax+204]
	xor	ecx, DWORD PTR _S$[ebp]
	xor	edx, esi
	mov	edi, ecx
	mov	ebx, edx
	shrd	edi, ebx, 13
	xor	ecx, edi
	shr	ebx, 13					; 0000000dH
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 8
	shl	edi, 8
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax+208]
	mov	DWORD PTR [eax+336], edi
	mov	edi, DWORD PTR tv4900[ebp]
	and	edi, DWORD PTR [eax+200]
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-188]
	and	edx, DWORD PTR [eax+100]
	mov	DWORD PTR tv4923[ebp], ecx
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR tv4923[ebp+4], ecx
	mov	ecx, DWORD PTR [eax-192]
	and	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR tv5639[ebp], edi
	xor	ecx, DWORD PTR tv5639[ebp]
	mov	edi, DWORD PTR tv4900[ebp+4]
	and	edi, DWORD PTR [eax+204]
	xor	ecx, DWORD PTR [eax-368]
	xor	edx, edi
	xor	edx, DWORD PTR [eax-364]
	xor	ecx, DWORD PTR tv4923[ebp]
	xor	edx, DWORD PTR tv4923[ebp+4]
	xor	ecx, DWORD PTR _S$[ebp]
	mov	DWORD PTR [eax+340], ebx
	xor	edx, esi
	mov	edi, ecx
	mov	ebx, edx
	shrd	edi, ebx, 11
	shr	ebx, 11					; 0000000bH
	xor	ecx, edi
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 15
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-180]
	and	edx, DWORD PTR [eax+108]
	shl	edi, 15					; 0000000fH
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax+216]
	mov	DWORD PTR tv5074[ebp], ecx
	mov	ecx, DWORD PTR [eax+220]
	mov	DWORD PTR tv5074[ebp+4], ecx
	mov	ecx, DWORD PTR [eax-184]
	and	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR [eax+348], ebx
	mov	ebx, DWORD PTR tv4923[ebp]
	and	ebx, DWORD PTR [eax+184]
	mov	DWORD PTR [eax+344], edi
	mov	edi, DWORD PTR tv4923[ebp+4]
	and	edi, DWORD PTR [eax+188]
	xor	ecx, ebx
	xor	ecx, DWORD PTR [eax-360]
	xor	edx, edi
	xor	edx, DWORD PTR [eax-356]
	xor	ecx, DWORD PTR tv5074[ebp]
	xor	edx, DWORD PTR tv5074[ebp+4]
	xor	ecx, DWORD PTR _S$[ebp]
	mov	DWORD PTR tv5623[ebp], ebx
	xor	edx, esi
	mov	edi, ecx
	mov	ebx, edx
	shrd	edi, ebx, 7
	xor	ecx, edi
	shr	ebx, 7
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 5
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-172]
	and	edx, DWORD PTR [eax+116]
	shl	edi, 5
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax+224]
	mov	DWORD PTR tv5257[ebp], ecx
	mov	ecx, DWORD PTR [eax+228]
	mov	DWORD PTR [eax+356], ebx
	mov	ebx, DWORD PTR tv5074[ebp]
	and	ebx, DWORD PTR [eax+192]
	mov	DWORD PTR tv5257[ebp+4], ecx
	mov	ecx, DWORD PTR [eax-176]
	and	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR [eax+352], edi
	mov	edi, DWORD PTR tv5074[ebp+4]
	and	edi, DWORD PTR [eax+196]
	xor	ecx, ebx
	xor	ecx, DWORD PTR [eax-352]
	xor	edx, edi
	xor	edx, DWORD PTR [eax-348]
	xor	ecx, DWORD PTR tv5257[ebp]
	xor	edx, DWORD PTR tv5257[ebp+4]
	xor	ecx, DWORD PTR _S$[ebp]
	mov	DWORD PTR tv5607[ebp], ebx
	xor	edx, esi
	mov	edi, ecx
	mov	ebx, edx
	shrd	edi, ebx, 6
	shr	ebx, 6
	xor	ecx, edi
	xor	edx, ebx
	mov	edi, ecx
	mov	ebx, edx
	shld	ebx, edi, 31
	xor	ebx, edx
	mov	edx, DWORD PTR [eax-164]
	and	edx, DWORD PTR [eax+124]
	shl	edi, 31					; 0000001fH
	xor	edi, ecx
	mov	ecx, DWORD PTR [eax-168]
	and	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR [eax+364], ebx
	mov	ebx, DWORD PTR tv5257[ebp]
	and	ebx, DWORD PTR [eax+200]
	mov	DWORD PTR [eax+360], edi
	mov	edi, DWORD PTR tv5257[ebp+4]
	and	edi, DWORD PTR [eax+204]
	xor	ecx, ebx
	xor	ecx, DWORD PTR [eax-344]
	xor	edx, edi
	xor	edx, DWORD PTR [eax-340]
	xor	ecx, DWORD PTR [eax+232]
	xor	edx, DWORD PTR [eax+236]
	xor	ecx, DWORD PTR _S$[ebp]
	xor	edx, esi
	mov	DWORD PTR tv5367[ebp], ebx
	mov	ebx, edx
	mov	edi, ecx
	shrd	edi, ebx, 12
	xor	ecx, edi
	shr	ebx, 12					; 0000000cH
	xor	edx, ebx
	mov	ebx, edx
	mov	edi, ecx
	shld	ebx, edi, 9
	xor	ebx, edx
	shl	edi, 9
	xor	edi, ecx
	mov	DWORD PTR [eax+368], edi
	mov	DWORD PTR [eax+372], ebx

; 233  : 
; 234  :       /* Advance round constant S to the next round constant. */
; 235  :       S = (S << 1) ^ (S >> (w-1)) ^ (S & Smask);

	mov	eax, DWORD PTR _S$[ebp]
	and	eax, 606457760				; 2425cfa0H
	mov	edx, esi
	shr	edx, 31					; 0000001fH
	xor	eax, edx
	mov	edx, DWORD PTR _S$[ebp]
	mov	ecx, esi
	shld	esi, edx, 1
	and	ecx, 1930543745				; 7311c281H
	xor	edi, edi
	add	edx, edx
	xor	ecx, edi
	xor	eax, edx
	xor	ecx, esi
	dec	DWORD PTR tv5345[ebp]
	mov	DWORD PTR _S$[ebp], eax

; 236  :       i += 16;

	mov	eax, DWORD PTR tv4624[ebp]
	mov	DWORD PTR _S$[ebp+4], ecx
	jne	$LL3@md6_main_c
	pop	edi
	pop	esi
	pop	ebx
$LN1@md6_main_c:

; 237  :     }
; 238  : }

	leave
	ret	0
_md6_main_compression_loop ENDP
_TEXT	ENDS
PUBLIC	_md6_compress
EXTRN	_free:PROC
EXTRN	_calloc:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogspy
;	COMDAT _md6_compress
_TEXT	SEGMENT
_C$ = 8							; size = 4
_N$ = 12						; size = 4
_r$ = 16						; size = 4
_A_as_given$ = 20					; size = 4
_A$ = 20						; size = 4
_md6_compress PROC					; COMDAT

; 266  : { md6_word* A_as_given = A;

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR _A$[ebp]
	push	esi

; 267  : 
; 268  :   /* check that input is sensible */
; 269  :   if ( N == NULL) return MD6_NULL_N;

	mov	esi, DWORD PTR _N$[ebp]
	mov	DWORD PTR _A_as_given$[ebp], ebx
	test	esi, esi
	jne	SHORT $LN7@md6_compre
	push	9
	jmp	$LN10@md6_compre
$LN7@md6_compre:

; 270  :   if ( C == NULL) return MD6_NULL_C;

	cmp	DWORD PTR _C$[ebp], 0
	jne	SHORT $LN6@md6_compre
	push	15					; 0000000fH
	jmp	SHORT $LN10@md6_compre
$LN6@md6_compre:

; 271  :   if ( r<0 || r > md6_max_r) return MD6_BAD_r;

	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	ja	SHORT $LN4@md6_compre

; 272  : 
; 273  :   if ( A == NULL) A = calloc(r*c+n,sizeof(md6_word));

	test	ebx, ebx
	jne	SHORT $LN2@md6_compre
	mov	eax, DWORD PTR _r$[ebp]
	shl	eax, 4
	add	eax, 89					; 00000059H
	push	8
	push	eax
	call	_calloc
	mov	ebx, eax
	pop	ecx
	pop	ecx

; 274  :   if ( A == NULL) return MD6_OUT_OF_MEMORY;

	test	ebx, ebx
	jne	SHORT $LN2@md6_compre
	push	18					; 00000012H
	jmp	SHORT $LN10@md6_compre
$LN2@md6_compre:
	push	edi

; 275  : 
; 276  :   memcpy( A, N, n*sizeof(md6_word) );    /* copy N to front of A */
; 277  : 
; 278  :   md6_main_compression_loop( A, r );          /* do all the work */

	push	DWORD PTR _r$[ebp]
	mov	ecx, 178				; 000000b2H
	mov	edi, ebx
	push	ebx
	rep movsd
	call	_md6_main_compression_loop

; 279  : 
; 280  :   memcpy( C, A+(r-1)*c+n, c*sizeof(md6_word) ); /* output into C */

	mov	eax, DWORD PTR _r$[ebp]
	mov	edi, DWORD PTR _C$[ebp]
	pop	ecx
	pop	ecx
	shl	eax, 7

; 281  : 
; 282  :   if ( A_as_given == NULL )           /* zero and free A if nec. */

	cmp	DWORD PTR _A_as_given$[ebp], 0
	push	32					; 00000020H
	pop	ecx
	lea	esi, DWORD PTR [eax+ebx+584]
	rep movsd
	pop	edi
	jne	SHORT $LN1@md6_compre

; 283  :     { memset(A,0,(r*c+n)*sizeof(md6_word)); /* contains key info */

	add	eax, 712				; 000002c8H
	push	eax
	push	0
	push	ebx
	call	_memset

; 284  :       free(A);           

	push	ebx
	call	_free
	add	esp, 16					; 00000010H
$LN1@md6_compre:

; 285  :     }
; 286  : 
; 287  :   return MD6_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN8@md6_compre
$LN4@md6_compre:

; 271  :   if ( r<0 || r > md6_max_r) return MD6_BAD_r;

	push	17					; 00000011H
$LN10@md6_compre:
	pop	eax
$LN8@md6_compre:
	pop	esi
	pop	ebx

; 288  : }

	pop	ebp
	ret	0
_md6_compress ENDP
_TEXT	ENDS
PUBLIC	_md6_make_control_word
; Function compile flags: /Ogspy
;	COMDAT _md6_make_control_word
_TEXT	SEGMENT
_r$ = 8							; size = 4
_L$ = 12						; size = 4
_z$ = 16						; size = 4
_p$ = 20						; size = 4
_keylen$ = 24						; size = 4
_d$ = 28						; size = 4
_md6_make_control_word PROC				; COMDAT

; 312  : { md6_control_word V;

	push	ebp
	mov	ebp, esp

; 313  :   V = ( (((md6_control_word) 0) << 60) | /* reserved, width  4 bits */
; 314  : 	(((md6_control_word) r) << 48) |           /* width 12 bits */
; 315  : 	(((md6_control_word) L) << 40) |           /* width  8 bits */
; 316  : 	(((md6_control_word) z) << 36) |           /* width  4 bits */
; 317  : 	(((md6_control_word) p) << 20) |           /* width 16 bits */
; 318  : 	(((md6_control_word) keylen) << 12 ) |     /* width  8 bits */
; 319  :         (((md6_control_word) d)) );                /* width 12 bits */
; 320  :   return V;

	mov	eax, DWORD PTR _r$[ebp]
	cdq
	shld	edx, eax, 8
	shl	eax, 8
	mov	ecx, eax
	mov	eax, DWORD PTR _L$[ebp]
	push	esi
	mov	esi, edx
	cdq
	or	ecx, eax
	mov	eax, DWORD PTR _z$[ebp]
	or	esi, edx
	shld	esi, ecx, 4
	shl	ecx, 4
	cdq
	or	ecx, eax
	mov	eax, DWORD PTR _p$[ebp]
	or	esi, edx
	shld	esi, ecx, 16
	cdq
	shl	ecx, 16					; 00000010H
	or	ecx, eax
	mov	eax, DWORD PTR _keylen$[ebp]
	or	esi, edx
	shld	esi, ecx, 8
	cdq
	shl	ecx, 8
	or	ecx, eax
	mov	eax, DWORD PTR _d$[ebp]
	or	esi, edx
	shld	esi, ecx, 12
	cdq
	shl	ecx, 12					; 0000000cH
	or	eax, ecx
	or	edx, esi
	pop	esi

; 321  : }

	pop	ebp
	ret	0
_md6_make_control_word ENDP
_TEXT	ENDS
PUBLIC	_md6_make_nodeID
; Function compile flags: /Ogspy
;	COMDAT _md6_make_nodeID
_TEXT	SEGMENT
_ell$ = 8						; size = 4
_i$ = 12						; size = 4
_md6_make_nodeID PROC					; COMDAT

; 339  :   U = ( (((md6_nodeID) ell) << 56) | 
; 340  : 	((md6_nodeID) i) );
; 341  :   return U;

	mov	eax, DWORD PTR _ell$[esp-4]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR _i$[esp-4]
	push	esi
	cdq
	xor	esi, esi
	shl	ecx, 24					; 00000018H
	or	eax, esi
	or	edx, ecx
	pop	esi

; 342  : }

	ret	0
_md6_make_nodeID ENDP
_TEXT	ENDS
PUBLIC	_md6_pack
; Function compile flags: /Ogspy
;	COMDAT _md6_pack
_TEXT	SEGMENT
_N$ = 8							; size = 4
_Q$ = 12						; size = 4
_K$ = 16						; size = 4
_ell$ = 20						; size = 4
_i$ = 24						; size = 4
_r$ = 28						; size = 4
_L$ = 32						; size = 4
_z$ = 36						; size = 4
_p$ = 40						; size = 4
_keylen$ = 44						; size = 4
_d$ = 48						; size = 4
_B$ = 52						; size = 4
_md6_pack PROC						; COMDAT

; 355  : { int j;

	push	ebp
	mov	ebp, esp

; 356  :   int ni;
; 357  :   md6_nodeID U;
; 358  :   md6_control_word V;    
; 359  : 
; 360  :   ni = 0;
; 361  : 
; 362  :   for (j=0;j<q;j++) N[ni++] = Q[j];       /* Q: Q in words     0--14 */

	mov	ecx, DWORD PTR _Q$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _N$[ebp]
	push	15					; 0000000fH
	pop	esi
	mov	eax, edi
	sub	ecx, edi
	mov	edx, esi
$LL6@md6_pack:
	mov	ebx, DWORD PTR [ecx+eax]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR [eax+4], ebx
	add	eax, 8
	dec	edx
	jne	SHORT $LL6@md6_pack

; 363  : 
; 364  :   for (j=0;j<k;j++) N[ni++] = K[j];       /* K: key in words  15--22 */

	mov	ecx, DWORD PTR _K$[ebp]
	xor	eax, eax
$LL3@md6_pack:
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [edi+esi*8], edx
	mov	edx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [edi+esi*8+4], edx
	inc	esi
	inc	eax
	cmp	eax, 8
	jl	SHORT $LL3@md6_pack

; 365  : 
; 366  :   U = md6_make_nodeID(ell,i);             /* U: unique node ID in 23 */
; 367  :   /* The following also works for variants 
; 368  :   ** in which u=0.
; 369  :   */
; 370  :   memcpy((unsigned char *)&N[ni],
; 371  : 	 &U,
; 372  : 	 min(u*(w/8),sizeof(md6_nodeID)));
; 373  :   ni += u;
; 374  : 
; 375  :   V = md6_make_control_word(
; 376  : 			r,L,z,p,keylen,d);/* V: control word in   24 */

	push	DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR _ell$[ebp]
	push	DWORD PTR _keylen$[ebp]
	cdq
	push	DWORD PTR _p$[ebp]
	mov	ecx, eax
	push	DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	push	DWORD PTR _L$[ebp]
	cdq
	push	DWORD PTR _r$[ebp]
	shl	ecx, 24					; 00000018H
	xor	ebx, ebx
	or	ebx, eax
	or	ecx, edx
	mov	DWORD PTR [edi+esi*8], ebx
	mov	DWORD PTR [edi+esi*8+4], ecx
	call	_md6_make_control_word

; 377  :   /* The following also works for variants
; 378  :   ** in which v=0.
; 379  :   */
; 380  :   memcpy((unsigned char *)&N[ni],
; 381  : 	 &V,
; 382  : 	 min(v*(w/8),sizeof(md6_control_word)));

	lea	ecx, DWORD PTR [edi+esi*8+8]

; 383  :   ni += v;
; 384  : 
; 385  :   memcpy(N+ni,B,b*sizeof(md6_word));      /* B: data words    25--88 */

	mov	esi, DWORD PTR _B$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
	lea	edi, DWORD PTR [ecx+8]
	add	esp, 24					; 00000018H
	mov	ecx, 128				; 00000080H
	rep movsd
	pop	edi
	pop	esi
	pop	ebx

; 386  : }

	pop	ebp
	ret	0
_md6_pack ENDP
_TEXT	ENDS
PUBLIC	_md6_standard_compress
EXTRN	__chkstk:PROC
; Function compile flags: /Ogspy
;	COMDAT _md6_standard_compress
_TEXT	SEGMENT
_A$ = -40712						; size = 40000
_N$ = -712						; size = 712
_C$ = 8							; size = 4
_Q$ = 12						; size = 4
_K$ = 16						; size = 4
_ell$ = 20						; size = 4
_i$ = 24						; size = 4
_r$ = 28						; size = 4
_L$ = 32						; size = 4
_z$ = 36						; size = 4
_p$ = 40						; size = 4
_keylen$ = 44						; size = 4
_d$ = 48						; size = 4
_B$ = 52						; size = 4
_md6_standard_compress PROC				; COMDAT

; 420  : { md6_word N[md6_n];

	push	ebp
	mov	ebp, esp
	mov	eax, 40712				; 00009f08H
	call	__chkstk

; 421  :   md6_word A[5000];       /* MS VS can't handle variable size here */
; 422  : 
; 423  :   /* check that input values are sensible */
; 424  :   if ( (C == NULL) ) return MD6_NULL_C;

	cmp	DWORD PTR _C$[ebp], 0
	push	esi
	jne	SHORT $LN13@md6_standa
	push	15					; 0000000fH
$LN20@md6_standa:
	pop	eax
	jmp	$LN14@md6_standa
$LN13@md6_standa:

; 425  :   if ( (B == NULL) ) return MD6_NULL_B;

	cmp	DWORD PTR _B$[ebp], 0
	jne	SHORT $LN12@md6_standa
	push	10					; 0000000aH
	jmp	SHORT $LN20@md6_standa
$LN12@md6_standa:

; 426  :   if ( (r<0) | (r>md6_max_r) ) return MD6_BAD_r;

	xor	ecx, ecx
	push	ebx
	mov	ebx, DWORD PTR _r$[ebp]
	mov	eax, 255				; 000000ffH
	cmp	ebx, eax
	setg	cl
	xor	edx, edx
	test	ebx, ebx
	sets	dl
	or	ecx, edx
	je	SHORT $LN11@md6_standa
	push	17					; 00000011H
	pop	eax
	jmp	$LN17@md6_standa
$LN11@md6_standa:

; 427  :   if ( (L<0) | (L>255) ) return MD6_BAD_L;

	xor	ecx, ecx
	push	edi
	mov	edi, DWORD PTR _L$[ebp]
	cmp	edi, eax
	setg	cl
	xor	edx, edx
	test	edi, edi
	sets	dl
	or	ecx, edx
	je	SHORT $LN10@md6_standa
	push	16					; 00000010H
	jmp	$LN19@md6_standa
$LN10@md6_standa:

; 428  :   if ( (ell < 0) || (ell > 255) ) return MD6_BAD_ELL;

	cmp	DWORD PTR _ell$[ebp], eax
	ja	$LN8@md6_standa

; 429  :   if ( (p < 0) || (p > b*w ) ) return MD6_BAD_p;

	cmp	DWORD PTR _p$[ebp], 4096		; 00001000H
	ja	$LN6@md6_standa

; 430  :   if ( (d <= 0) || (d > c*w/2) ) return MD6_BADHASHLEN;

	mov	esi, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, 511				; 000001ffH
	ja	$LN4@md6_standa

; 431  :   if ( (K == NULL) ) return MD6_NULL_K;

	cmp	DWORD PTR _K$[ebp], 0
	jne	SHORT $LN3@md6_standa
	push	13					; 0000000dH
	jmp	$LN19@md6_standa
$LN3@md6_standa:

; 432  :   if ( (Q == NULL) ) return MD6_NULL_Q;

	cmp	DWORD PTR _Q$[ebp], 0
	jne	SHORT $LN2@md6_standa
	push	14					; 0000000eH
	jmp	SHORT $LN19@md6_standa
$LN2@md6_standa:

; 433  : 
; 434  :   /* pack components into N for compression */
; 435  :   md6_pack(N,Q,K,ell,i,r,L,z,p,keylen,d,B);

	push	DWORD PTR _B$[ebp]
	lea	eax, DWORD PTR _N$[ebp]
	push	esi
	push	DWORD PTR _keylen$[ebp]
	push	DWORD PTR _p$[ebp]
	push	DWORD PTR _z$[ebp]
	push	edi
	push	ebx
	push	DWORD PTR _i$[ebp]
	push	DWORD PTR _ell$[ebp]
	push	DWORD PTR _K$[ebp]
	push	DWORD PTR _Q$[ebp]
	push	eax
	call	_md6_pack

; 436  : 
; 437  :   /* call compression hook if it is defined. */
; 438  :   /* -- for testing and debugging.           */
; 439  :   if (compression_hook != NULL)

	mov	eax, DWORD PTR _compression_hook
	add	esp, 48					; 00000030H
	test	eax, eax
	je	SHORT $LN16@md6_standa

; 440  :     compression_hook(C,Q,K,ell,i,r,L,z,p,keylen,d,B);

	push	DWORD PTR _B$[ebp]
	push	esi
	push	DWORD PTR _keylen$[ebp]
	push	DWORD PTR _p$[ebp]
	push	DWORD PTR _z$[ebp]
	push	edi
	push	ebx
	push	DWORD PTR _i$[ebp]
	push	DWORD PTR _ell$[ebp]
	push	DWORD PTR _K$[ebp]
	push	DWORD PTR _Q$[ebp]
	push	DWORD PTR _C$[ebp]
	call	eax
	add	esp, 48					; 00000030H
$LN16@md6_standa:

; 441  : 
; 442  :   return md6_compress(C,N,r,A);

	lea	eax, DWORD PTR _A$[ebp]
	push	eax
	push	ebx
	lea	eax, DWORD PTR _N$[ebp]
	push	eax
	push	DWORD PTR _C$[ebp]
	call	_md6_compress
	add	esp, 16					; 00000010H
	jmp	SHORT $LN18@md6_standa
$LN4@md6_standa:

; 430  :   if ( (d <= 0) || (d > c*w/2) ) return MD6_BADHASHLEN;

	push	2
	jmp	SHORT $LN19@md6_standa
$LN6@md6_standa:

; 429  :   if ( (p < 0) || (p > b*w ) ) return MD6_BAD_p;

	push	12					; 0000000cH
	jmp	SHORT $LN19@md6_standa
$LN8@md6_standa:

; 428  :   if ( (ell < 0) || (ell > 255) ) return MD6_BAD_ELL;

	push	11					; 0000000bH
$LN19@md6_standa:
	pop	eax
$LN18@md6_standa:
	pop	edi
$LN17@md6_standa:
	pop	ebx
$LN14@md6_standa:
	pop	esi

; 443  : }

	leave
	ret	0
_md6_standard_compress ENDP
_TEXT	ENDS
END
